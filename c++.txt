

-string:
	- the string is nothing but array of character where it ends with "/0" so the software can knows where it ends
	- there are 3 way to define the string:
		- 1 - char* p = "ahmed" : it would be stored in read memory so it is constant so the actual defination of this variable is const char* a = "ahmed\0"
		- 2 char a[] = "ahmed" : the compiler would create an array of char and put the value in it that means this is read / write area in the memory
		
		- string a = "ahmed" : that is an class which has more capability on the string

- malloc and new:
	- both of them would allocate memory which it can be used but malloc wont call the constructor, the same goes for free and delete, only delete would call the destrcutor.
	
	- any time u call new u should call delete. and new[] should call delete[]

- pointers:
	- as a rule always use smart pointers 
	- unique Pointers are pinter which doesnot have copy constructor
	- ex:
		- auto myUniPointer = make_unique<int>(12)
		- this would create a pointe and allocate 12 integer size for this pointer
		- u can pass unique Pointer with move semantic
		- unique_ptr newPointer = move(oldPointer);
		
	- shared pointers are the same no big difference in the semantic rather than u just have to use shared instead of unique
	


- array:
	- it is nothing but a contingious arra of memory with the same size 
	
	- if u want to pass array to a function:
		void func(int *) or void func(int[]) both are the same 
		when u call the function : func(&array1[0])
		
	- if u want to pass array by reference it is only possible if u define a function which takes fixed size area
		void func(int(&arry)[4])
		
- I/O streaming:
	- std::endl -> it flush the buffer



- design rules:
	
	- abstraction:
		- u seperate the interface from the implmentation 
		- you should be  able to use the code without relying on the implementation
	
- Lvalue:
	- something which can take reference from
	- u can cast Lvalue reference to Rvalue using move ex: std::move()
	
- Rvalue:
	- anything which is not Lvaue
	- && to reference Rvalue
	
		
- class:
	- define the class by writing class myclass {};  -> it should end with ; as it is a statment
	- class has members which is a date member "variable" or  member functions "constructor, destructore or method"
	- any method that does not change a member function should be declared as :const
		ex: double getValue() const;
	- 
	
- access control:
	- there are three types of access controll public, private and protected
	- the default one is private if u didnot define anything
	
- this keyword:
	- it represent the the object which instanced the class
	- if a method takes an object and u want to call this method from the class u use *this
	- ex: 1.1 

- Initializer-List Constructors:	
	- An initializer-list constructor is a constructor with an std::initializer_list<T> as first parameter,
	- u can call size on the list to get the size and u can use loop range based 
	- for (auto i : args)

- contstructor:
	- it should have the same name as the class
	- if the constructor doesnot take any arrgument we call it a default constructor 
	
- copy sonstructor:
	- it takes const reference to the source object
	- ex: SpreadsheetCell(const SpreadsheetCell& src);
	- it is called:
		- when u pass an object to a function or mehtod
		- when u return object from a function
	- it can return anything as it is constrcutor
	
			
- Assignment Operator:
	- it is called when u use "=" and it is not in declaration phase
	- ex: 
		SpreadsheetCell myCell(5);
		SpreadsheetCell anotherCell(myCell);
		SpreadsheetCell aThirdCell = myCell; that is a copy constructor as the = is with defination stage
		- classname& operator=(const classname& rhs); at the end u have to return *this
		- when u return from the function in which u return an obect 
		- the copy construcotr would be so or so invocaed in order to create the obejct which we should return,
		- then the operator or the copy constrcutor would be invoked to create the other object
		
- const Reference Data Members:
	- There is an important difference between using a const object versus a non-const object. The const object can call only const methods.

- static:
	- it is a way to create globa√∂ variable but with name space of the class.
	- u declare the variable in .h and define the variable in .c file


- reference:
	- it must be initialized once it is created
	- You cannot create a reference to an unnamed value
	- int& unnamedRef1 = 5; // DOES NOT COMPILE
	- const int& unnamedRef2 = 5; // Works as expected
	- if u define function parameter as reference the compiler would pass the address of the variable so u can perform changes on the variables which would affect the input also
	
	*important*
	- return be reference means the function would return the same object and it wont create a new one 
		ex:
			obj& function(obj&) {return &obj}
	- u have to remember although the function would return a new object if u want to have the same object u have to define the variable which would take it also as reference 
	
- const keyword:
	- the value of the pointer is constant:
	ex:
		const int* ip;
		ip = new int[10];
		ip[4] = 5; //error
	
	- the pointer points to constant area:
	- ex:
		- int* const ip = new int[10];
		- ip[4] = 5; //ok
	
	- if u define a function which take constant means that the function wont change the object but the object should not be a constant object

- inheritance:
	- it is a way to extend the class, u make the child class is a parent class but with more capability
	- a pointer of type base can point to both type base and derived
	- only method which are declared virtual can be good overwritten in the derivd class.In the derived class u delcare the method as virtual and u mark it as override
	- calling of construcor is first parent and then the derived class




		
- container:
	- generic data type that are useful for storing collection of data there are 16 containers with 4 types:
		- sequential: vector, list, array, 
		- assoctiative: map, set
		- container adaptors: stack, queue

	- container use value semmantic pass value be value so when u add element to the container u add a copy of the cotainer not the actuall     element, in case of emplace method u add the actual object not a copy from the object
	
	- container has methods:
		- Move Constructor : Used when the source element is an rvalue, and will be destroyed after the construction
		- Copy Constructor : Used every time you insert an element, except when using an emplace method (discussed

- iterators:
	- pointer to a specific element of the container
	- Every container class in the Standard Library that supports iterators provides public type aliases for its iterator types, called 	iterator and const_iterator
	- example of an iterator of vector which has integers values
		std::vector<int>iterator 
	- int arry[] = {1, 2, 3, 4, /* end */ }; the end refere to past one from the actual range
	- iteraor has:
		- begin : return the first element which is a refernce to this element if u made change to this element u change the element in the container
		- end : return past the end by one
		- cbegin : const first element
		
- vector:
	- contructor in vector:
		- default: vector<int> intVector; // Creates a vector of ints with zero elements
		- vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
		- vector<int> intVector2{ 1, 2, 3, 4, 5, 6 }; using with initialize list
		- to access elements in vectors u can use at or []
			at: will perform boundary check
		
		- iterator in vectors:
			- for (const auto& element : stringVector)
			- this gives the reference to the element because u used &  any changes in the element would be also inside the vector
			- without & u takes a copy of the element not the element it self.
		- if u used begin and end it return an address u have to reference it to change thte element
		
		- to add element:
			- vec.push_back(myElement)
			
		- u can use iterator to iterate over the element and reference the iterator to change the elements or u can use range loop base with auto to access the element

- list:
	- it support constant time insertion and deletation
	- it does not support random access of element u donot have operator like []
	- push_back: add element to the end of the list
	- push_front : add element to the beging of the list
	- front: return the first element
	- back: return the last element of the list
	- pop_back: remove the last element in the list
	- pop_front: remove the first element in the list
	
- array:
	- it is declared in the header file <array>
	- it has size method to get the size of the array and it supported random access using [] and at 
	
	
- queue:
	- queue it is a template to support first in first out method
	- push to add element to the tail 
	- pop remove the element from the front
	- to retrive the element use front and back u get reference to the element

- Map:
	- pair is the ability to group two different element together pair<string,in>mypair("hello",5)
	- if u want to add an element to the map u use insert which take initalizier list or pair and return pair of the element and bool to represent if the insertion successed
	- insert_or_assign method would overwrite the element if the element exist u can use [] operator it works as insert_or_assign operator
	if u want to know if an element exist use find which would return the iterator or end

