Programming: Principles and Practice Using C++
- Concepts:
	- c++ is a superset of c means it can anything which c can do plus extra abilities
	- it is called c with class 
	- the modern c++ is starting from c++11
	- you can see c++ is a language which consists of 4 parts
		- c: as it has header, datatype, pointers, array
		- class: constructor, method, attribute
		- Template: general programming
		- stl: the standard template where string, map, vector is implemeneted
- types:
	- char: it is 8 bits which can have 255 value like 'a','1';
	- integer: 1 
	- u can find the size of a type using sizeof an example sizeof(int)
	bool:
		- the type is defined by bool
		- u can convert from integer to bool and the other way around as true is one and false is zero
		- u can make sum and substraction on bool as it would be converted 1 and 0 if u then store the value back to the variable it would be considered as true and false 
	char:
		- it is represented as 8 bits which means it can have 256 values
		- char belongs to the integer group which means u can perform mathitcal operation on them " + and - "
		- u can covert the char to integer 
		- '1' if u changed it to ineger u wont get 1 u will get 48
		- int {'1'} would yield 48 
		- c - '0'  to get the integer value form getchar function 
	- enum:
		- it is a user define data type where u can give a name to integer value
		- enum has a global name space
		- ex:
			enum color{WHITE, RED, YELLOW};
			color myColor;
			myColor = white;
	- enum class:
		- it is strong typed means u cannot compare it with another enum of a different type or direct with an integer
		- ex:
			enum class PieceType{ King = 1, Queen = 2};
			PieceType piece = PieceType::King;
	- typedef:
		- it is a way to create an alias for a variable 
		- u dont create a new variable u just make an alias
		- ex:
			typedef int Boolean
			const Boolean True = 1
			const Boolean False = 0;
		- another example:
			- typedef real list[50];
			- list list1; that would create 50 element array of type real
	- array:
		- it is nothing but a contingious area of memory with the same size 
		- if u want to pass array to a function:
			void func(int *) or void func(int[]) both are the same 
			when u call the function : func(&array1[0])
		- array is passed only be reference as the name of the array is the address of the first element in the array
		- if u want to pass array by reference it is only possible if u define a function which takes fixed size area
			void func(int(&arry)[4])
	- struct:
		- it is a way to create data types which consist of different data types
		- ex:
			- struct name_of_struct { int a; int b; real c};
			- name_of_struct my_struct;
		- u cannot compare two struct with each other
		- u can copy the whole struct by assigning the struct to another struct
		- u can pass struct both by reference or by value while array is passed only by reference because the name of the array is the address of the first element
	- pair:
		- it is a way create 2 element which acts as a pair
		- std::pair<T1,T2> p
		- std::pair<T1,T2> p(piecewise_construct, t1, t2) 
			- create a pair from tuple t1 and t2
			- std::pair<int,Foo> p2 (piecewise_construct, make_tuple(42), t);
		- p.first, p.second access the element
		- u can force to pass reference to the pair 
		- ex:
			int i = 0;
			auto p = std::make_pair(std::ref(i),std::ref(i));
			p.first++; // i would increase also
	- tuple:
		- u can bind more than 2 types to a single unit
		- auto x = make_tuple(22,"S", 1.1);
		- tuple<int,float,string> t1(41,6.3,"nico");
		- std::get<0> = 12;

- template:
	- it is something like micro
	- funtion would be created when we call it 
	- template<typename T > 
		function1(T a) {return a;};
	- template specializing: 
		template<>
		function1(char a) {return a + "s";};
	- u can define nonetype template
		template<int a>
	- to work by reference 
		template<typeName T>
		T& function1(T& a, T&c){return c;};
	- return type deducing 
		template<typeName T, typeName P>
		auto function1(T& a, P&c){return c;};
		- this would return the bigger size of u both type
	- decltype it is used to make the return type general
		template<typename T, typename P>
		auto max(T t, P p) -> declType((t > p ) ? t : p ){ return t;}
	- vardiic template
	ex:
		void printMessage();
		template<typename T, typename... types>
		void printMessage(const T& firstArgs, const types&... args) {
			std::cout << firstArgs << " \n";
			printMessage(args...);
		}

- type deducation:
	- Reference function:
		- we ignore reference means T would never be deduced to ref
	- ex:
		template<typename T>
		void f(T& param)
		int x = 22 			-> T = int 			-> paramtype = int&
		const int cx = 22 	-> T = const int 	-> paramtype = const int&
		const int& rc = 22 	-> T-> const int 	-> paramtype = const int&

	- const reference function
		- we ignore reference means T would never be deduced to ref
		- we ignore also constant means T would never be deduced by const
	- ex:
		template<typename T>
		void f(const T& param)
		int x = 22 			-> T = int 			-> paramtype = const int&
		const int cx = 22 	-> T = int 			-> paramtype = const int&
		const int& rc = 22 	-> T-> int 			-> paramtype = const int&

	- universal reference: 
		- would bind to both R and L value
	- ex:
		template<typename T>
		void f(T&& param)
		int x = 22 			-> T = int& 		-> paramtype = int&
		const int cx = 22 	-> T = const int& 	-> paramtype = const int&
		const int rx = x 	-> T = const int& 	-> paramtype = const int&
		f(22) 				 -> T-> int 		-> paramtype = const int&&

	- by value 
		- nothing is considered as the variable would be copied 
	- ex:
		template<typename T>
		void f(const T param)
		int x = 22 			-> T = int		-> paramtype = int
		const int cx = 22 	-> T = int		-> paramtype = int
		const int rx = x 	-> T = int		-> paramtype = int
		f(22) 				-> T = int		-> paramtype = int	

- decltype:
	- expression if it is lvalue expression u get lvalue reference 
	- ex:
		decltype(arr[0]) -> would return int& as the array is lvalue
	- if u pass a variable and the variable has name would return the declare type of that variable
	- ex:
		int x = 1;
		decltype(x) would return int

- return type deducation:
	- auto
		- function would return the template return type
		- that would never return reference
	- decltype(auto) would return decltype rule which has to do with expression would retuurn reference

- move semantic:
	- we use && which accept lValue and Rvalue and would keep this type 
	- std::forward is conditonally move so in the template if u passed lvalue it remains l if u passed rvalue it remain r

- function binding:
	- lvalue parameter:
		- bind with lvalue reference, template with forward reference, const lvalue  
		- ex:
			- Widget w{}
			- f(w)
			- f(Widget&)
			- template<typename T>
				f(T&&)
			- f(const Widget&)
	- const lvalue parameter:
		- bind with const lvalue ref, forward reference 
		- const Widget w{}
			- f(w)
			- f(const Widget&)
			- template<typename T>
				f(T&&)
			- f(const Widget&)
	- rvalue :
		- bind with rvalue, and forwarding reference, const lvalue 
		- f(getWidget)
			- f(Widget&&)
			- f(const Widget&)
			- template<typename T>
				f(T&&)
		
- Initialization:
	- there are 4 type pf intialization 
	T x {a} -> no narrowing down and the best way to go
	T x (a) -> using constructor
	T x = a -> using assigning 
	T x = {} -> using assiging with initalization list	
- variables:
	- declaration is the process of telling the compiler the name and the type but u dont occupy any memory
		- ex: 
			- extern int i;
			- void function_1 (void);
			- class Widget;
	- defination: it is the process of occupying the memory 
		- ex:
			- int x;
			- int function_1(void){ return 1;}
	- assigning:
		- ex:
			- Widget w1; -> default constructor
			- widget w2(w1); -> copy constructore
			- w1 = w2; -> copy assigment operator
			- Widget w3 = w1 -> copy constructor

- Lvalue:
	- something which can take reference from
	- u can cast Lvalue reference to Rvalue using move ex: std::move()
- Rvalue:
	- anything which is not Lvaue
	- && to reference Rvalue	
	- if u want to change lvalue to rvalue u have to use move semantic std::move
	- return value is automatically used by move and can be bind to rValue if u return a local variable 

- reference:
	- it must be initialized once it is created
	- You cannot create a reference to an unnamed value
	- int& unnamedRef1 = 5; // DOES NOT COMPILE
	- const int& unnamedRef2 = 5; // Works as expected
	- if u define function parameter as reference the compiler would pass the address of the variable so u can perform changes on the variables which would affect the input also
	
	*important*
	- return be reference means the function would return the same object and it wont create a new one 
	- you should not return an object which would not be exists after calling the function like a local variable inside the function  
		ex:
			obj& function(obj&) {return &obj}
	- u have to remember although the function would return a new object if u want to have the same object u have to define the variable which would take it also as reference 
	- const reference means u want the function not to copy the object but u want it in order to save time not because u want to change the object
- const keyword:
	- const means i promise i wont change the value of the variable 
	- the value of the pointer is constant:
	ex:
		const int* ip;
		ip = new int[10];
		ip[4] = 5; //error	
	- the pointer points to constant area:
	- ex:
		- int* const ip = new int[10];
		- ip[4] = 5; //ok
	- if u define a function which take constant means that the function wont change the object but the object should not be a constant object
	- if u want to limit the scope of the const to a class u should make it member function and to make one copy of it u have to make it static. in this case u provide the initial value of the static const integer member in the .h file and u define it in .c file
	- ex:
		- static const int NumTurns = 5; -> .h file
		- 
	- constexpr:
		- means u want to the value to be computed in the compilation time not in run time the expression should be simple with return 
		- variable of const expression can take it value from a function only if the fuction returns constexpression 
- allocation of memory:
	- if u want to allocate memory in heap u use new keyword
	- new would create a variable in the stack with points to the heap 
	- after using the variable u have to delete the variavle using delete keyword 
	- new and delete call the constrcutor and destructor
	- ex:
		int *x = new int;
		delete x;
		x = nullptr;
	- u can allocate array. which is a pointer which point to the first element in the array
	- it has the advantage that u can create it at the run time but once u create it u cannot change it"s size 
	- ex:
		- int *x = new int[5];
		- delete [] x;
		- x = nullptr;
- malloc and new:
	- both of them would allocate memory which it can be used but malloc wont call the constructor, the same goes for free and delete, only delete would call the destrcutor.
	- any time u call new u should call delete. and new[] should call delete[]
- pointers:
	- double pointer:
		- pointers which point to another point 
		- ex:
			- int** dptr = nullptr;
			- dptr = new int*;
			- *dptr = new int;
			- **dptr = 5;
			- if u want to work with double array
			- Spreadsheet** mcells;
			- mcells = new Spreadsheet*[width];
			- for(int i = 0; i < width ; i++){
				mcelss[i] = new Spreadsheet[height];
			}
	- nullptr would call the fuction which is overloaded with pointer
	ex:
		void f(int);
		void f(void*);
		f(0); // calls f(int)
		f(NULL); // calls f(int) if NULL is 0, ambiguous otherwise
		f(nullptr);

	- as a rule always use smart pointers 
- unique Pointers: 
	-	are pointer which doesnot have copy constructor
	- it is used for exclusive ownership
	- ex:
		- auto myUniPointer = make_unique<int>(12)
		- this would create a pointe and allocate 12 integer size for this pointer
		- auto mySimpleSmartPointer = std::make_unique<Simple>()
		- u can change the unique pointer to raw pointer using get method on the pointer 
		- ex:
			mySimpleSmartPointer* ratPointer =  mySimpleSmartPointer.get()
		- u can free the resource by calling reset on the pointer
		- ex:
			- mySimpleSmartPointer.reset()
		- u can pass unique Pointer with move semantic
		- unique_ptr newPointer = move(oldPointer);	
		- u can pass it to function 
		-ex 
			function1(std::move(oldPointer))
		- u can pass it be reference 
			function1(const std::unique<Shape>& x )
			here constant doesnot mean u can call only call constant method, it means u cannot change the pointer like reset the pointer 
		- return unique pointer happens without problem as the compiler whould call the move semantic automatically 

	- shared pointers are the same no big difference in the semantic rather than u just have to use shared instead of unique
	- ex:
		- std::shared_ptr<Entity> smartptr1 = std::make_shared<Entity>();
		- std::shared_ptr<Entity> smartptr2(smartptr1); 
	- weak_ptr:
		- it is very useful when u work with circular dependicy
		- if u have two objects which point to each other u have to use weak pointer for one of them so the object might be deleted an example the father point to the child and the child point to the father
		- to access weak pointer u have first to check with expire and then use lock on it 
		- ex:
			ptr.expire()
			pt.lock()->sum()  
- class:
	- define the class by writing class myclass {};  -> it should end with ; as it is a statment
	- class has members which is a date member "variable" or  member functions "constructor, destructore or method"
	- any method that does not change a member function should be declared as :const
		ex: double getValue() const; 
- object:
	- object can be passed to a function by reference or by value 
	- generally speaking u delcare the function to take reference if u want to change the object or u declare it as const reference if u dont want to change the object
	- ex:
		void function1(&object1) function which would change the object 
		void function2(const& object1) function which wont change the object 
	- it can be returned from a function also

- access modifier:
	- there are three types of access controll public, private and protected
	- the default one is a private if u did not define anything
	- access controller is about who is allowed to call the method or access the member element
	- protected means the derived class is allowed to call this method or access this member
	- private means only the base class is allowed to access this member no one else is allowed to perform this action 
- this keyword:
	- it represent the the object which instanced the class
	- if a method takes an object and u want to call this method from the class u use *this
- contstructor:
	- it should have the same name as the class
	- if the constructor doesnot take any arrgument we call it a default constructor
- constructor delegation:
	- it is a way that u call another constructor from the constructor in constructor list 
	- u are not allowed to call anything else rather than the constructor in constructor list anything else should be called in the body of the constructor  
- Constructor Initializers:
	- u use it to initialize data member of the class as the class have to initilaize the data member befor calling the construtor. using Constructor Initializers u make sure that the data member would be right initilized with the right values.
	- very important rule the data is initilized with the order of the defination of the class not with the order they are calles from the the constructor 
- Initializer-List Constructors:	
	- An initializer-list constructor is a constructor with an std::initializer_list<T> as first parameter, u have to include <initializer_list> header
	- u can call size on the list to get the size and u can use loop range based 
	- for (auto& i : args)
	- u can call size, end, begin on the initialize list 
	-  for range is enables on any thing which has begin() and end() and return iterator/ pointer
- copy constructor:
	- it takes const reference to the source object
	- ex: SpreadsheetCell(const SpreadsheetCell& src);
	- it is called:
		- when u pass an object to a function or method by value
		- when u return object from a function
		- u can call copy constructor explicity
		- ex:
			- SpreadsheetCell myCell1(4);
			- SpreadsheetCell myCell2(myCell1); 
	- it cannot return anything as it is constrcutor
- Assignment Operator:
	- it is called when u use "=" and it is not in declaration phase
	- ex: 
		SpreadsheetCell myCell(5);
		SpreadsheetCell anotherCell(myCell);
		SpreadsheetCell aThirdCell = myCell; that is a copy constructor as the = is with defination stage
		aThirdCell = myCell; here it is copy assign as the object was already created before u call the assign operator 
		- classname& operator=(const classname& rhs); at the end u have to return *this
		- u have first to make a temperory object store the data and copy the data to it before u delete the object because if the object point to something and u have delete it beforeu copy the program won't work the right way 
		- when u return from the function in which u return an obect 
		- the copy construcotr would be so or so invocaed in order to create the obejct which we should return,
		- then the operator or the copy constrcutor would be invoked to create the other object	

- explicit:
	- u should define constructor which can take a single argument as explicit to prevent the constructor from converting 
	- struct X {
		explicit X();
		explicit X(int,int);
		};
	- X x = {1} or X x = {1,2} would cause an erorr
	- X x {1} or X x {1,2} ok
	- int f(X);
	- int i1 = f({}); // error : implicit
	- int i2 = f({1,2}); // error : implicit
	- int i3 = f(X{}); // OK: explicit
	- int i4 = f(X{1,2}); // OK: explicit

- destructor:
	- it is called when the object goes out of the scope 
	- if u use pointer to the stack then when u call delete 
	- with smart pointer it is called automatically  
- const Reference Data Members:
	- There is an important difference between using a const object versus a non-const object. The const object can call only const methods.
- static:
	- it is a way to create global variable but with name space of the class.
	- u declare the variable in .h and define the variable in .c file but u dont write the word static in the .c file
	- ex:
		- inside the .h file
			class Spreadsheet{
				private:
				static size_t sCounter;};
		- inside the .c file to occupy space in memory 
			size_t Spreadsheet::sCounter; or size_t Spreadsheet::sCounter = 0;
	- if u are using static constant u can define and intialize them inside the class in the .h file u dont have to use the .c file 
	- ex:
		- inside .h file 
			class Spreadsheet{
			public:
				static const size_t kMaxHeight = 100;
				static const size_t kMaxWidth = 100;};

- inheritance:
	- it is a way to extend the class, u make the child class is a parent class but with more capability or adjustable behaviour 
	- it works only with pointers and reference
	- if u want to define abstact class u use virtual and = 0
	ex:
		-  virtual double& operator[](int) = 0;
	- a pointer of type base can point to both type base and derived
	- only method which are declared virtual can be good overwritten in the derived class. In the derived class u delcare the method as virtual and u mark it as override, it works only with pointer to an object.
	- once method is defined as virtual it is virtual in all derived classes 
	- calling of construcor is first parent and then the derived class
	- stpes of creation of the derived class:
		- base default constructor is called if u donot call a specific constructor within ctor
		- data member of the base class is constructed if there are any data member which has constructor it would be called first before the constructor of the class is called 
		- u cannot pass member data to the constructor of the base class as it is not initalized 
		- body of base constructor is excuted
	- steps of destructor:
		- the body of the derived destructor is called
		- data member is deleted 
		- body of parent destructor is called 

	- public inheritance:
		- u can use the derived class polymorphically
		- u can call the protected and the private method of the base class
		- it is used to implemenet us-a relatiionship
	- protected and private:
		- u cannot use the base and derived polymorphically
		- all the protected and the private member would be protected or private means u can still call them in the derived base but u cannot call them from the derived object
		- it is used to say that the derived call implement the base class 

- Casting:
	- up casting is ok means the base pointer or reference points to derived object 
	- ex:
		Base& myBase = myDerived;

	- down casting is more a problems means that the derived object points to base using dynamic_cast
	- it is dangerous and it should be avoided 
	- ex:
		Derived myDerived = dynamic_cast<Derived*> myBase;

- stadanrd Library:
	- it uses the namespace std so to use an element in the standard library u have to use std::
- container:
	- generic data type that are useful for storing collection of data there are 16 containers with 4 types:
		- sequential: vector, list, array, 
		- assoctiative: map, set
		- container adaptors: stack, queue
	- container use value semmantic pass value be value so when u add element to the container u add a copy of the cotainer not the actuall     element, in case of emplace method u add the actual object not a copy from the object
	
	- container has methods:
		- Move Constructor : Used when the source element is an rvalue, and will be destroyed after the construction
		- Copy Constructor : Used every time you insert an element, except when using an emplace method (discussed
- string:
	- the string is nothing but array of character where it ends with "/0" so the software can knows where it ends
	- there are 3 way to define the string:
		- 1 - char* p = "ahmed" : it is c style string
			- it is a pointer which points to the string which is stored in the code section
			- it would be stored in read memory so it is constant so the actual defination of this variable is const char* a = "ahmed\0"
			- sizeof() -> would give the size of the pointer which might br 4 or 8 or 2 depending of the system
		- 2 char a[] = "ahmed": it is c style string
			- it is an array
			- the compiler would create an array of char and put the value in it that means this is read / write area in the memory
			- sizeof() -> would give the size of the string + null terminated
			- u can use extended string to print the string with some features
				- const char *var = R"-(any thing / \ u can write" with space ) and without )-";
			- string it automatically conside const char * if u want it to be defined as string u have to add "s add the end
			- u can convert string to integer using the following methods
				- std::string_literals;
				- auto string = "anything"s; -> this would be consided as string
		- string a = "ahmed" : that is an class which has more capability on the string	
	- string_view:
		- read only string u define it so the function can take the string and work on it 
- streaming:
	- c++ provide a stream interface to communicate with input output interfaces
	- because it is only an interface we dont care if it is keyboard or console or internet u can direct the i/o to any thing
	- u use the header file iostream to include both input and output header files
	- the stream tends to buffer data in order to send the data u can call flush(), std::endl;, or calling cin would case the output buffer to flush
	- using cin would read the data and store data in a variable according to the variable type and it read till the white space, tab or newline u cannot read a whole line using this method
	- cin.getline() -> it is used to read a line till end of line character
	- u can get more than 1 variables if u concatenate the cin
	- ex:
		- cin >> var1 >> var2 >> var3
	- cin.get(char)
		- it would read the next charachter includeing the whitespace
	- cin.putchar(char)
		- it would return the character to the input stream
	- char a = cin.peek()
		- it would read the next character without removing it from the input stream
	- cin.ignore(int, char)
		- ignore the next number of character or the next expression depending on which happens first 
		
	ios: it is the base for the input output 
	ifstream: input operation  for a file
	ofstream: output operation	outout operation for a file
	fstream: input output operation for a file
	cin: connected to standard input and it is instance of istream
	cout: connected to standard output it is instance of ostream
	std::cin >> var : would take an input from the user and save it in the var, it read the data which the user has entered until the user press enter
	- to format string:
		std::cout<<std::boolalpha 
		std::cout.setf(std::ios::boolalpha)	
		std::dec
		std::hex
		std::oct
	- ostringsream:
		- it is defined in the header file #include<sstream>
		- it allows u to use buffer where u can write to it and then print it using cout 
		- ex:
			std::ostringstream os
			os << "write something in the buffer so i can print it later \n";
			os << "keep writing something in the buffer \n"
			std:: string  myString = " string variable ";
			os << myString;
			std::cout << os.str(); ;

- exception:
	- it is catch through concept 
	- the code which find the error which through the exception while the code which handle the error would catch it
	- it is recommended to through an object 
	- object should be copyable 
	- noexcept:
		- exceptions are not allowed to propraged 
		- if the error was not handled in the function the programm would be terminated
		- u add this qualifer when u know that this function wont throw an exception so there is no need for the function to be placed inside try catch block
		- destructors are noexcept be dafault
	- ex: 
		- #include <stdexcept>
		double SafeDivide(double num, double den){
			if (den == 0)
			throw invalid_argument("Divide by zero");
			return num / den;}
		int main()
		{
		try {
			cout << SafeDivide(10, 0) << endl;
		} catch (const invalid_argument& e) {
		cout << "Caught exception: " << e.what() << endl;
		}
		return 0;}
	- invalid_argument it is class which support what which is const char* var
	- you can through exception which is general exception 
	- ex:
		- throw exception();
	- general match:
		- catch (...) {
			cerr << "Error reading or opening file " << fileName << endl;
			return 1;}
- function object:
	- it is an object which has the () operator defined
	- 
- containers:
	- there are 4 types of containers
	- Sequential:
		- array / vector / list / forward_list / deque
	- Associative:
		- map / set / multimap / multiset
	adaptors:
		- queue / stack / priority_queue
	- they work with values not with reference
	- they implement basic operations
	- copy constructor when u add element
	- move constructor when u add element which is R value
	- assigment operator when u modify an element

- iterators:
	- pointer to a specific element of the container
	- Every container class in the Standard Library that supports iterators provides public type aliases for its iterator types, called 	iterator and const_iterator
	- example of an iterator of vector which has integers values
		std::vector<int>iterator 
	- int arry[] = {1, 2, 3, 4, /* end */ }; the end refere to past one from the actual range
	- iteraor has:
		- begin() : return the first element which is a refernce to this element if u made change to this element u change the element in the container
		- end() : return past the end by one
		- cbegin() : const first element
		- cend()
		- all this method can be called on the container to get an iterator 
		-ex:
			for auto elem& : coll) {
				elem = 12 // here element is referenced 
				}	

	- iterator enables for based for loop where u can get the element from the container
	auto system_start = chrono::system_clock::now();

- algoritms:
	- they work on on iterators
	- u can search, replace, sort 
	- the header file is <algoritms>
	- std::all_of: 
		-would return true if all of them fit the codition  
		if (std::all_of(std::cbegin(vec), std::cend(vec), [](int i) { return  i % 2 == 1;  })) {
		std::cout << "odd \n";}
	- std::any_of: 
		- would return true if any element fit the condition 
	- std::find:
		- u search if an element is in the containter it take a range 
		- it return the iterator / index if the iterator is avaliable of the end iterator 
		- auto index = find(cbegin(myvector),cend(myvector),theElementUareIntertedIn);
	- min_element:
		- to find the minimal element in a container would return an iterator which u need to deference 
		- ex:
			auto minpos = min_element(coll.cbegin(),coll.cend());
			std::cout << *minpos
	- find_if:
		- return the first iterator which would return true
		- ex:
			auto pos = find_if (coll.cbegin(), coll.cend(), isPrime);
			- pos here is iterator which u need to dereference in order to get the value 
	- for_each:
		- ex:
			for_each (coll.cbegin(), coll.cend(),print);
		- u can use it to call also operator()
			- ex:
				for_each (coll.cbegin(), coll.cend(), PrintInt());
				- hier we created object on the fly which then would be called from for_each
				- it has more benefits as this way u have a way to pass variable in the function as closure and then the function would be called with this value closure in Javascript the same concept
		- u can use also method
			- ex:
				for_each (coll.cbegin(), coll.cend(), Person::save());

	- copy:
		- std::vector v1,v2
		- std::copy(v1.begin(), v1.end(), back_inserter(v2) );

	- remove:
		- list:
			- remove the element and move the following element to this position and keep the size the same
			- ex:
				remove (coll.begin(), coll.end(),3);
				pre: 6 5 4 3 2 1 1 2 3 4 5 6
				post: 6 5 4 2 1 1 2 4 5 6 5 6
			- if u want to erase the element and change the size:
			ex:
				coll.erase (remove(coll.begin(),coll.end(),3),coll.end());
	replace_if / replace:
		- u can use it to change the value in container with a new value
		- std::replace(arr, arr + n, old_val, new_val);
		- std::replace_if(arr, arr + n, IsOdd, new_val)

	- assign:
		- this would erase the old values and assign the new value to the container 
		- ex:
			std::vector<int> v1{1,2,3};
			v1.assign(5,100)
			- the vector would have 5 elemens and the value would be 100
		- if u used it with iterator u would get the iterator copied 
		ex:
			std::list<Elem> l;
			std::vector<Elem> coll;
			coll.assign(l.begin(),l.end());
			- this would copy the list to the container 
	- insert:
		- it is used to insert element or elements to the container 
	- erase:
		- it is used to erase an iterator from the container u have to give it an iterator 
		
	- std::transform it is used to operator on container and create new create based on a function in the container 
	- ex:
		std::transform(vec1.begin(), vec1.end(), std::back_inserter(vec2), std::negate<int>());
	for (auto& i : vec2) {
		std::cout << i << "\n";
	}

	- std::accumlate(vec.begin(), vec.end(), 0);

	- std::bind:
		- u can use to to provide argument to function which u would call at later time in the future
		- ex:
			auto plus10 = std::bind(std::plus<int>(),std::placeholders::_1, 10);
			std::cout << "+10: " << plus10(7) << std::endl;

- vector:
	- it is allocated in the heap
	- it enables dynamic access
	- u can get the size of the vector using size()
	- contructor in vector:
		- default: vector<int> intVector; // Creates a vector of ints with zero elements
		- vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
		- vector<int> intVector2{ 1, 2, 3, 4, 5, 6 }; using with initialize list
		- std::vector<int> vec(10);
			- that would create vector which has the size of 10 elements
		- it support random access
	- to access elements in vectors u can use at or []
		at: will perform boundary check
		front(): would return a reference to the first element
		back(): would return a reference to the last element of container 
		begin(vector): would return the first iterator in the array u have to dereference it
		end(vector): would return past end element which is the element after the end
		vector.erase(iteraor): erase the element which has this iterator
		pop_back():
			- to delete the last element from the vector u can use pop_back()
	- vector is by default passed be value not be reference if u want the vector by passed by reference u have to create a function which is designed to accpet the value be reference

	- iterator in vectors:
		- for (const auto& element : stringVector)
		- this gives the reference to the element because u used &  any changes in the element would be also inside the vector
		- without & u takes a copy of the element not the element it self.
	- if u used begin and end it return an address u have to reference it to change the element
	- to add element:
		- vec.push_back(myElement)
		- this makes a copy of the element and woulf be added to the list 
		 
	- to clear the vector u can call .clear()
	- to iterator starting from the second element std::next()		
	- u can use iterator to iterate over the element and reference the iterator to change the elements or u can use range loop base with auto to access the element
	- if u return a vector from function it would return using move sematic which means it would be fast 
	- ex:
		vector<int> createVectorOfSize(size_t size)
		{
			vector<int> vec(size);
			int contents = 0;
			for (auto& i : vec) {
				i = contents++;}
			return vec;}
		vector<int> myVector;
		myVector = createVectorOfSize(123);

- list:
	- double linked list
	- it support constant time insertion and deletation
	- it does not support random access of element u donot have operator like []
	- push_back: add element to the end of the list
	- push_front : add element to the beging of the list
	- front: return the first element as Reference
	- back: return the last element of the list as Reference 
	- pop_back: remove the last element in the list
	- pop_front: remove the first element in the list
	- splice: u add list to another list starting from a specific point in the first list and the second list would be empty out

- deque:
	- double ended queue 
	- vector which allows inserting from front and from the end
	- u can insert element using push_back and push_front which is the difference between the deque and the vector
	- 
- forward_list:
	- single linked list

- array:
	- it is allocated in the stack 
	- it is declared in the header file <array>
	- it has size method to get the size of the array and it supported random access using [] and at 
	- std::array< 5, std::string>
		- array which has 5 elements and all it is elements are integer 
	- at() : return the element at the index
	- front() : return the first element
	- back() : return the last element

- set:
	- it doesnot allow duplication

- queue:
	- queue it is a template to support first in first out method (FIFO)
	- push to add element to the tail 
	- pop remove the element from the front
	- to retrive the element use front and back u get reference to the element
- Map:
	- pair is the ability to group two different element together pair<string,in>mypair("hello",5)
	- if u want to add an element to the map u use insert which take initalizier list or pair and return pair of the element and bool to represent if the insertion successed
	- insert_or_assign method would overwrite the element if the element exist u can use [] operator it works as insert_or_assign operator
	if u want to know if an element exist use find which would return the iterator or end

- pairs:
	- it handles two values as a single unit 
	- ex: woukd be map, unordered_map 
	- we use key value to represent pairs
	- it is defined in utility header file 
	- to access u data u can uswe first and second on the pair 
	- to create pair
		- std::pair<int, std::string> p(5, "ahmed");

- ternary operator 
	return t1 > t2 ?  t1 :  t2;

- function:
	- lambda functions:
		- signature : [capture list] (parameters) -> return type { function body };
		- auto func = [](){std::cout << "hi there "; return 12; } ;
		- u can call it automatically 
			- [] ( ) {std::cout << "hi "}();
		- capture list it is a way to pass data to the lambda so the lambda function can have access of them
		- remember it is capture means u take one value of the variable
		- u can capture by reference and then the value inside the function would remain the same 
		- u can capture everything by value, u can use [=] to capture everything
		- u can capture everything by reference using [&] to capture everything by reference 
		- u can use std::function tp declare function
		- ex:
			- std::function<void(int, float)> f 
			- f = function1;
			- f(1,1.0);
			- here u declared function with the name f which takes 2 args and return nothing
			- u assifn function1 to it
			- then u can call it 

- chrono:
	- it is libaray which has API which can be used to workt with the time 
	- there are another way to use platform dependent 
	- why we need chrono:
		- it has unit like second, minutes, millsecond
	- Seconds
		- u can find it under std::chrono::seconds 
		- u can initalize it using:
			- seconds s{};
		- u can not implicit it to integer u always has to use inializer list
		- to get the value of the second u have to use:
			- s.count();
		- to pass it to a function u have to use constructor 
			- function(seconds(3));
			- function(3s);
			- function(3); it wont compile
	- duration it is a way to define period of time
	- std::chrono::duration<int> sec(20);
	- std::chrono::duration<double,std::ration<60>> halfMinute(0.5);
	- to get the start time from a specific point of the code 
		- auto system_start = chrono::system_clock::now();

- future:
	- it gives the possibilty to wait on a result
	- u can fire the event as a backgroud process and get the result when it is available
	- ex:
		std::future<int> result1(std::async(func1));
		int result2 = func2();
		int result = result1.get() + result2;
	- u can decide the function should start excute right now 
		ex: 
			std::future<long> result1= std::async(std::launch::async, func1);
	- can can wait on a background thread
		std::future<...> f(std::async(func));
		f.wait()
	- std::this_thread::yield();
		- it is used to release the thread
- promise:
	- it is the opposite of future
	- it gives u a way to pass data to the function later 
	- u tell the function that i promise i would provide the data but not right now
	-	
- mutexes and lock:
	std::mutex valMutex;
	valMutex.lock();
	valMutex.unlock();

	std::lock_guard<std::mutex> lg(valMutex);
	- this would unlick by destructor 

	- u can use recursive lock to avoid dead lock 
		std::recursive_mutex dbMutex;
		std::lock_guard<std::recursive_mutex> lg(dbMutex);
		std::lock_guard<std::recursive_mutex> lg(dbMutex);

/*
-------------------------------------------------------------------------------------
Style
*/
 
- u can write a comment that the function can throw an exception if something happens
	- ex:	
			/*
			* saveRecord			*
			* Saves the given record to the database.
			*
			* Parameters:
			* 	Record& record: the record to save to the database.
			* Returns: int
			* 	An integer representing the ID of the saved record.
			* Throws:
			* 	DatabaseNotOpenedException if the openDatabase() method has not
			* 	been called yet.
			*/

- u can write a comment to a file
	- ex:
		/*
		* Author: marcg
		* Date: 110412
		* Feature: PRD version 3, Feature 5.10
		*/

- u can write to do also:
	- ex:
		// TODO: What if setId() throws an exception? â€“ akshayr 110501

- Naming conventation:
	- counter:
		- u can use i or j
	- Data member:
		- u can use m 
		ex:
			- mData or m_Data
	- static:
		- u can use s to indicate it is static 
		-ex:
			- sLookup
	- boolen:
		- u can use is 
		- ex:
			- isCompleted 

- design:
	- multil tiered:
		- u divide the software in layer ex: presentation, logic, data layer
		- data and presentation communicate only through logic the never communicate with each other directly
	- MVC:
		- model, view, control

/*
----------------------------------
design pattern :
*/

Adapter:
	- make interface to adapt to another interface 

- Prototype:
	- Model object which we can make copy of it, customize it and then use it  

- pimple:
	- the concept that u declare a class as a private member of another class and then u implement this class in .cpp file and use this implementation in the first file

- observer:
	- it is about push from data not pulling it

- command:
	- it is a way to enable do and undo request
	- u encapselt the request in a form of object
	- it consists of invoker, command and receiver

- prototype:
	- 

- best practise:
	- using wrapper:
		- limited public interface
		- u can change the underline implimtation 
/*
----------------------------------
booster:
*/

- boost::any -> provide a generic type which can be integer or string or anything 
- boost::variant -> union which can be one of a predefined types  
- boost::array:
 	- u can define a fixed size array using typedef boost::array<char, 4> array4_t;
 	- the first parameter is the type and the second element is the size

/*
----------------------------------
open CV:
*/
