Programming: Principles and Practice Using C++
- Concepts:
	- c++ is a superset of c means it can anything which c can do plus extra abilities
	- it is called c with class 
	- the modern c++ is starting from c++11
	- you can see c++ is a language which consists of 4 parts
		- c: as it has header, datatype, pointers, array
		- class: constructor, method, attribute
		- Template: general programming
		- stl: the standard template where string, map, vector is implemeneted
- types:
	- char: it is 8 bits which can have 255 value like 'a','1';
	- integer: 1 
	- u can find the size of a type using sizeof an example sizeof(int)
	bool:
		- the type is defined by bool
		- u can convert from integer to bool and the other way around
		- u can make sum and substraction on bool as it would be converted 1 and 0 if u then store the value back to the variable it would be considered as true and false 
	char:
		- it is represented as 8 bits which means it can have 256 values
		- char belongs to the integer group which means u can perform mathitcal operation on them " + and - "
		- u can covert the char to integer 
		- '1' if u changed it to ineger u wont get 1 u will get 48
		- int {'1'} would yield 48 
		- c - '0'  to get the integer value form getchar function 
	- enum:
		- it is a user define data type where u can give a name to integer value
		- enum has a global name space
		- ex:
			enum color{WHITE, RED, YELLOW};
			color myColor;
			myColor = white;
	- typedef:
		- it is a way to create an alias for a variable 
		- u dont create a new variable u just make an alias
		- ex:
			typedef int Boolean
			const Boolean True = 1
			const Boolean False = 0;
			

- Initialization:
	- there are 4 type pf intialization 
	T x {a} -> no narrowing down and the best way to go
	T x (a) -> using constructor
	T x = a -> using assigning 
	T x = {} -> using assiging with initalization list	
- variables:
	- declaration is the process of telling the compiler the name and the type but u dont occupy any memory
		- ex: 
			- extern int i;
			- void function_1 (void);
			- class Widget;
	- defination: it is the process of occupying the memory 
		- ex:
			- int x;
			- int function_1(void){ return 1;}
	- assigning:
		- ex:
			- Widget w1; -> default constructor
			- widget w2(w1); -> copy constructore
			- w1 = w2; -> copy assigment operator
			- Widget w3 = w1 -> copy constructor
- Lvalue:
	- something which can take reference from
	- u can cast Lvalue reference to Rvalue using move ex: std::move()
- Rvalue:
	- anything which is not Lvaue
	- && to reference Rvalue	
	- if u want to change lvalue to rvalue u have to use move semantic std::move
- reference:
	- it must be initialized once it is created
	- You cannot create a reference to an unnamed value
	- int& unnamedRef1 = 5; // DOES NOT COMPILE
	- const int& unnamedRef2 = 5; // Works as expected
	- if u define function parameter as reference the compiler would pass the address of the variable so u can perform changes on the variables which would affect the input also
	
	*important*
	- return be reference means the function would return the same object and it wont create a new one 
	- you should not return an object which would not be exists after calling the function like a local variable inside the function  
		ex:
			obj& function(obj&) {return &obj}
	- u have to remember although the function would return a new object if u want to have the same object u have to define the variable which would take it also as reference 
	- const reference means u want the function not to copy the object but u want it in order to save time not because u want to change the object
- const keyword:
	- the value of the pointer is constant:
	ex:
		const int* ip;
		ip = new int[10];
		ip[4] = 5; //error	
	- the pointer points to constant area:
	- ex:
		- int* const ip = new int[10];
		- ip[4] = 5; //ok
	- if u define a function which take constant means that the function wont change the object but the object should not be a constant object
	- if u want to limit the scope of the const to a class u should make it member function and to make one copy of it u have to make it static but u have to define it in the .c file
	- constexpr:
		means u want to the value to be computed in the compilation time not in run time the expression should be simple
- allocation of memory:
	- if u want to allocate memory in heap u use new keyword
	- new would create a variable in the stack with points to the heap 
	- after using the variable u have to delete the variavle using delete keyword 
	- new and delete call the constrcutor and destructor
	- ex:
		int *x = new int;
		delete x;
		x = nullptr;
	- u can allocate array. which is a pointer which point to the first element in the array
	- it has the advantage that u can create it at the run time but once u create it u cannot change it"s size 
	- ex:
		- int *x = new int[5];
		- delete [] x;
		- x = nullptr;
- malloc and new:
	- both of them would allocate memory which it can be used but malloc wont call the constructor, the same goes for free and delete, only delete would call the destrcutor.
	- any time u call new u should call delete. and new[] should call delete[]
- pointers:
	- double pointer:
		- pointers which point to another point 
		- ex:
			- int** dptr = nullptr;
			- dptr = new int*;
			- *dptr = new int;
			- **dptr = 5;
			- if u want to work with double array
			- Spreadsheet** mcells;
			- mcells = new Spreadsheet*[width];
			- for(int i = 0; i < width ; i++){
				mcelss[i] = new Spreadsheet[height];
			}
	- as a rule always use smart pointers 
	- unique Pointers are pointer which doesnot have copy constructor
	- ex:
		- auto myUniPointer = make_unique<int>(12)
		- this would create a pointe and allocate 12 integer size for this pointer
		- u can pass unique Pointer with move semantic
		- unique_ptr newPointer = move(oldPointer);	
	- shared pointers are the same no big difference in the semantic rather than u just have to use shared instead of unique
	- ex:
		- std::shared_ptr<Entity> smartptr1 = std::make_shared<Entity>();
		- std::shared_ptr<Entity> smartptr2(smartptr1); 
- class:
	- define the class by writing class myclass {};  -> it should end with ; as it is a statment
	- class has members which is a date member "variable" or  member functions "constructor, destructore or method"
	- any method that does not change a member function should be declared as :const
		ex: double getValue() const; 
- access control:
	- there are three types of access controll public, private and protected
	- the default one is private if u didnot define anything
- this keyword:
	- it represent the the object which instanced the class
	- if a method takes an object and u want to call this method from the class u use *this
- contstructor:
	- it should have the same name as the class
	- if the constructor doesnot take any arrgument we call it a default constructor 
- Constructor Initializers:
	- u use it to initialize data member of the class as the class have to initilaize the data member befor calling the construtor. using Constructor Initializers u make sure that the data member would be right initilized with the right values.
	- very important rule the data is initilized with the order of the defination of the class not with the order they are calles from the the constructor 
- Initializer-List Constructors:	
	- An initializer-list constructor is a constructor with an std::initializer_list<T> as first parameter, u have to include <initializer_list> header
	- u can call size on the list to get the size and u can use loop range based 
	- for (auto& i : args)
- copy constructor:
	- it takes const reference to the source object
	- ex: SpreadsheetCell(const SpreadsheetCell& src);
	- it is called:
		- when u pass an object to a function or method by value
		- when u return object from a function
		- u can call copy constructor explicity
		- ex:
			- SpreadsheetCell myCell1(4);
			- SpreadsheetCell myCell2(myCell1); 
	- it cannot return anything as it is constrcutor
- Assignment Operator:
	- it is called when u use "=" and it is not in declaration phase
	- ex: 
		SpreadsheetCell myCell(5);
		SpreadsheetCell anotherCell(myCell);
		SpreadsheetCell aThirdCell = myCell; that is a copy constructor as the = is with defination stage
		aThirdCell = myCell; here it is copy assign as the object was already created before u call the assign operator 
		- classname& operator=(const classname& rhs); at the end u have to return *this
		- when u return from the function in which u return an obect 
		- the copy construcotr would be so or so invocaed in order to create the obejct which we should return,
		- then the operator or the copy constrcutor would be invoked to create the other object	
- destructor:
	- it is called when the object goes out of the scope 
	- if u use pointer to the stack then when u call delete 
	- with smart pointer it is called automatically  
- const Reference Data Members:
	- There is an important difference between using a const object versus a non-const object. The const object can call only const methods.
- static:
	- it is a way to create global variable but with name space of the class.
	- u declare the variable in .h and define the variable in .c file but u dont write the word static in the .c file
	- ex:
		- inside the .h file
			class Spreadsheet{
				private:
				static size_t sCounter;};
		- inside the .c file to occupy space in memory 
			size_t Spreadsheet::sCounter; or size_t Spreadsheet::sCounter = 0;
	- if u are using static constant u can define and intialize them inside the class in the .h file u dont have to use the .c file 
	- ex:
		- inside .h file 
			class Spreadsheet{
			public:
				static const size_t kMaxHeight = 100;
				static const size_t kMaxWidth = 100;};
- inheritance:
	- it is a way to extend the class, u make the child class is a parent class but with more capability or adjustable behaviour 
	- it works only with pointers and reference 
	- a pointer of type base can point to both type base and derived
	- only method which are declared virtual can be good overwritten in the derived class. In the derived class u delcare the method as virtual and u mark it as override, it works only with pointer to an object.
	- once method is defined as virtual it is virtual in all derived classes 
	- calling of construcor is first parent and then the derived class
	- stpes of creation of the derived class:
		- base default constructor is called if u donot call a specific constructor within ctor
		- data member of the base class is constructed if there are any data member which has constructor it would be called first before the constructor of the class is called 
		- u cannot pass member data to the constructor of the base class as it is not initalized 
		- body of base constructor is excuted
	- steps of destructor:
		- the body of the derived destructor is called
		- data member is deleted 
		- body of parent destructor is called 
- stadanrd Library:
	- it uses the namespace std so to use an element in the standard library u have to use std::
- container:
	- generic data type that are useful for storing collection of data there are 16 containers with 4 types:
		- sequential: vector, list, array, 
		- assoctiative: map, set
		- container adaptors: stack, queue
	- container use value semmantic pass value be value so when u add element to the container u add a copy of the cotainer not the actuall     element, in case of emplace method u add the actual object not a copy from the object
	
	- container has methods:
		- Move Constructor : Used when the source element is an rvalue, and will be destroyed after the construction
		- Copy Constructor : Used every time you insert an element, except when using an emplace method (discussed
- string:
	- the string is nothing but array of character where it ends with "/0" so the software can knows where it ends
	- there are 3 way to define the string:
		- 1 - char* p = "ahmed" : it is c style string
			- it is a pointer which points to the string which is stored in the code section
			- it would be stored in read memory so it is constant so the actual defination of this variable is const char* a = "ahmed\0"
			- sizeof() -> would give the size of the pointer which might br 4 or 8 or 2 depending of the system
		- 2 char a[] = "ahmed": it is c style string
			- it is an array
			- the compiler would create an array of char and put the value in it that means this is read / write area in the memory
			- sizeof() -> would give the size of the string + null terminated
			- u can use extended string to print the string with some features
				- const char *var = R"-(any thing / \ u can write" with space ) and without )-";
			- string it automatically conside const char * if u want it to be defined as string u have to add "s add the end
			- u can convert string to integer using the following methods
				- std::string_literals;
				- auto string = "anything"s; -> this would be consided as string
		- string a = "ahmed" : that is an class which has more capability on the string	
- streaming:
	- c++ provide a stream interface to communicate with input output interfaces
	- because it is only an interface we dont care if it is keyboard or console or internet u can direct the i/o to any thing
	- u use the header file iostream to include both input and output header files
	- the stream tends to buffer data in order to send the data u can call flush(), std::endl;, or calling cin would case the output buffer to flush
	- using cin would read the data and store data in a variable according to the variable type and it read till the white space u cannot read a whole line using this method
	- cin.getline() -> it is used to read a line till end of line character
	ios: it is the base for the input output 
	ifstream: input operation  for a file
	ofstream: output operation	outout operation for a file
	fstream: input output operation for a file
	cin: connected to standard input and it is instance of istream
	cout: connected to standard output it is instance of ostream
	std::cin >> var : would take an input from the user and save it in the var, it read the data which the user has entered until the user press enter
	- to format string:
		std::cout<<std::boolalpha 
		std::cout.setf(std::ios::boolalpha)	
		std::dec
		std::hex
		std::oct

- exception:
	- it is catch through concept 
	- the code which find the error which through the exception while the code which handle the error would catch it
	- it is recommended to through an object 
	- ex: 
		- #include <stdexcept>
		double SafeDivide(double num, double den){
			if (den == 0)
			throw invalid_argument("Divide by zero");
			return num / den;}
		int main()
		{
		try {
			cout << SafeDivide(10, 0) << endl;
		} catch (const invalid_argument& e) {
		cout << "Caught exception: " << e.what() << endl;
		}
		return 0;}
	- invalid_argument it is class which support what which is const char* var
	- you can through exception which is general exception 
	- ex:
		- throw exception();
	- general match:
		- catch (...) {
			cerr << "Error reading or opening file " << fileName << endl;
			return 1;}
- containers:
	- there are 4 types of containers
	- Sequential:
		- array / vector / list / forward_list / deque
	- Associative:
		- map / set / multimap / multiset
	adaptors:
		- queue / stack / priority_queue
	- they work with values not with reference
	- they implement basic operations
	- copy constructor when u add element
	- move constructor when u add element which is R value
	- assigment operator when u modify an element

- array:
	- it is nothing but a contingious arra of memory with the same size 
	- if u want to pass array to a function:
		void func(int *) or void func(int[]) both are the same 
		when u call the function : func(&array1[0])
	- if u want to pass array by reference it is only possible if u define a function which takes fixed size area
		void func(int(&arry)[4])
- iterators:
	- pointer to a specific element of the container
	- Every container class in the Standard Library that supports iterators provides public type aliases for its iterator types, called 	iterator and const_iterator
	- example of an iterator of vector which has integers values
		std::vector<int>iterator 
	- int arry[] = {1, 2, 3, 4, /* end */ }; the end refere to past one from the actual range
	- iteraor has:
		- begin : return the first element which is a refernce to this element if u made change to this element u change the element in the container
		- end : return past the end by one
		- cbegin : const first element

- algoritms:
	- they woron on iterators
	- the header file is <algoritms>
	find:
		- u search if an element is in the containter it take a range 
		- it return the iteratoe if the iterator is avaliable of the end iterator 
		- auto it = find(cbegin(myvector),cend(myvector),theElementUareIntertedIn);
- vector:
	- contructor in vector:
		- default: vector<int> intVector; // Creates a vector of ints with zero elements
		- vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
		- vector<int> intVector2{ 1, 2, 3, 4, 5, 6 }; using with initialize list
		- to access elements in vectors u can use at or []
			at: will perform boundary check
			front(): would return a reference to the first element
			back(): would return a reference to the last element of container 
			begin(vector): would return the first iterator in the array u have to dereference it
			end(vector): would return past end element which is the element after the end
		- iterator in vectors:
			- for (const auto& element : stringVector)
			- this gives the reference to the element because u used &  any changes in the element would be also inside the vector
			- without & u takes a copy of the element not the element it self.
		- if u used begin and end it return an address u have to reference it to change thte element
		- to add element:
			- vec.push_back(myElement)
		- to clear the vector u can call .clear()
		- to iterator starting from the second element std::next()		
		- u can use iterator to iterate over the element and reference the iterator to change the elements or u can use range loop base with auto to access the element
- list:
	- it support constant time insertion and deletation
	- it does not support random access of element u donot have operator like []
	- push_back: add element to the end of the list
	- push_front : add element to the beging of the list
	- front: return the first element
	- back: return the last element of the list
	- pop_back: remove the last element in the list
	- pop_front: remove the first element in the list
- array:
	- it is declared in the header file <array>
	- it has size method to get the size of the array and it supported random access using [] and at 
- queue:
	- queue it is a template to support first in first out method
	- push to add element to the tail 
	- pop remove the element from the front
	- to retrive the element use front and back u get reference to the element
- Map:
	- pair is the ability to group two different element together pair<string,in>mypair("hello",5)
	- if u want to add an element to the map u use insert which take initalizier list or pair and return pair of the element and bool to represent if the insertion successed
	- insert_or_assign method would overwrite the element if the element exist u can use [] operator it works as insert_or_assign operator
	if u want to know if an element exist use find which would return the iterator or end